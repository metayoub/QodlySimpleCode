shared singleton constructor()
	
function test(request : 4D.IncomingMessage)->res : 4D.OutgoingMessage
	trace
	res = 4D.OutgoingMessage.new()
	
function upload(request : 4D.IncomingMessage)->res : 4D.OutgoingMessage
	var myBlob : 4D.Blob = 4D.Blob.new()
	var bodyBlob : 4D.Blob = 4D.Blob.new()
	var body, boundary, newFileName : string
	var parts : collection
	var part : object
	var myFile : 4D.File
	var myFolder : 4D.Folder = folder("/SOURCES/Shared").folder("files")
	trace
	res = 4D.OutgoingMessage.new()
	
	myBlob = request.getBlob()
	bodyBlob = myBlob.slice(0, 1024)  // trying only to get the first line
	body = convertToString(bodyBlob, 4)  //iso-8859-1
	boundary = this.GetMultipartBoundary(body)
	
	if (boundary != "")
		parts = this.multipartParse(myBlob, boundary)
	end 
	
	forEach (part, parts)
		if (part.isFile)
			trace
			// save it
			newFileName = generateUUID+part.fileName
			myFile = myFolder.file(newFileName)
			myFile.create()
			myFile.setContent(part.data)
		else 
			// Example: handle text fields if you need them.
			// var txt : String = part.textValue  // already decoded below
		end 
	end 
	
	res.setHeader("content-type", "text/plain; charset=utf-8")
	res.setBody("OK")
	
function GetMultipartBoundary(body : string)->out : string
	// 1) Try from header (case-insensitive, handles quotes and extra params)
	var posFound, lengthFound : integer
	// Look for the first boundary marker anywhere (works even if the body looks “flat”)
	if (matchRegex("--([A-Za-z0-9'()+_,./:=?\\-]+)", body, 1, posFound, lengthFound))
		out = substring(body, posFound, lengthFound)
	else 
		out = ""
	end 
	
function multipartParse(myblob : 4D.Blob, boundary : string)->out : collection
	var delim, finalDelim, body : string
	var lenDelim : integer
	var pos, cursor : integer
	var CRLF : string = char(13)+char(10)
	
	// header parsing
	var headersStart, headersEnd : integer
	var headersTxt, line : string
	var pCRLF, pLF, sepLen : integer
	
	// playload
	var partStart, partEnd : integer
	var nextPos, nextCR, nextLF : integer
	var slice : 4D.Blob
	
	// Meta
	var name, fileName : string
	var contentType, charset : string
	var item : object
	var isFinal : boolean
	var ctPos, ctLen, afterCT, pCRLFCRLF, pLFLF : integer
	var txt : string
	
	out = []
	
	// Convert whole body to Latin-1 text (1 bytes) for robust scanning
	body = convertToString(myblob, 4)  // ISO-8859-1 view for 1:1 byte scanning
	
	delim = boundary  // e.g. "--WebKitFormBoundaryXYZ"
	finalDelim = boundary+"--"  // final boundary marker
	lenDelim = length(delim)
	
	// Find first boundary
	pos = position(delim, body, 1)
	cursor = pos
	if (pos > 0)
		while (true)
			// If this boundary is the final one, stop
			if (substring(body, cursor, lenDelim+2) == finalDelim)
				break
			end 
			trace
			// Move to start of headers (just after boundary + newline)
			headersStart = cursor+lenDelim
			if (substring(body, headersStart, 2) == CRLF)
				headersStart = headersStart+2
			else 
				if (substring(body, headersStart, 1) == char(10))
					headersStart = headersStart+1  // careful: +1 (LF only)
				end 
			end 
			
			// ---- Read headers (until blank line) ----
			pCRLF = position(char(13)+char(10)+char(13)+char(10), body, headersStart)
			pLF = position(char(10)+char(10), body, headersStart)
			
			if ((pCRLF != 0) & ((pLF == 0) | (pCRLF < pLF)))
				headersTxt = substring(body, headersStart, pCRLF-headersStart)
				headersEnd = pCRLF+4
				sepLen = 4
			else 
				if (pLF != 0)
					headersTxt = substring(body, headersStart, pLF-headersStart)
					headersEnd = pLF+2
					sepLen = 2
				else 
					headersTxt = ""
					headersEnd = headersStart
					sepLen = 0
				end 
			end 
			
			// --- Determine partStart (prefer blank line after Content-Type) ---
			partStart = headersEnd
			/*if (matchRegex("(?im)^content-type\\s*:\\s*.*$", body, headersStart, ctPos, ctLen))
				afterCT = ctPos+ctLen
				if (substring(body, afterCT, 4) == char(13)+char(10)+char(13)+char(10))
					partStart = afterCT+4
				else 
					if (substring(body, afterCT, 2) == char(10)+char(10))
						partStart = afterCT+2
					else 
						pCRLFCRLF = position(char(13)+char(10)+char(13)+char(10), body, afterCT)
						pLFLF = position(char(10)+char(10), body, afterCT)
						if ((pCRLFCRLF != 0) & ((pLFLF == 0) | (pCRLFCRLF < pLFLF)))
							partStart = pCRLFCRLF+4
						else 
							if (pLFLF != 0)
								partStart = pLFLF+2
							end 
						end 
					end 
				end 
			end */
			
			// --- Find next boundary FROM partStart (anchor to newline + delim) ---
			nextCR = position(CRLF+delim, body, partStart)
			nextLF = position(char(10)+delim, body, partStart)
			
			if ((nextCR != 0) & ((nextLF == 0) | (nextCR < nextLF)))
				nextPos = nextCR+2  // start of delim
			else 
				if (nextLF != 0)
					nextPos = nextLF+1
				else 
					// Fallback: search raw delim (rare but safe)
					nextPos = position(delim, body, partStart)
					if (nextPos == 0)
						nextPos = length(body)+1  // till end
					end 
				end 
			end 
			
			// --- Trim trailing newline right before boundary and set partEnd ---
			partEnd = nextPos-1
			if ((partEnd >= 2) & (substring(body, partEnd-1, 2) == CRLF))
				partEnd = partEnd-2
			else 
				if ((partEnd >= 1) & (substring(body, partEnd, 1) == char(10)))
					partEnd = partEnd-1
				end 
			end 
			
			
			// --- Slice payload BYTES from original blob (explicit length always) ---
			slice = 4D.Blob.new()
			if (partEnd >= partStart)
				slice = myblob.slice(partStart-1 , partEnd+1)
			end 
			
			// --- Parse key headers you care about (name, filename, contentType, charset) ---
			name = ""
			fileName = ""
			contentType = ""
			charset = ""
			
			if (matchRegex("(?im)^content-disposition\\s*:\\s*.*$", body, headersStart, pCRLF, pLF))
				line = substring(body, pCRLF, pLF)
				if (matchRegex("(?i)name\\s*=\\s*\"([^\"]+)\"", line, 1, pCRLF, pLF))
					name = substring(line, pCRLF+6, pLF-7)  // strip name=""
				end 
				if (matchRegex("(?i)filename\\*?\\s*=\\s*\"?([^\";\\r\\n]+)\"?", line, 1, pCRLF, pLF))
					fileName = substring(line, pCRLF+10, pLF-11)  // strip filename=""
				end 
			end 
			
			if (matchRegex("(?im)^content-type\\s*:\\s*([^;\\r\\n]+)", body, headersStart, pCRLF, pLF))
				contentType = substring(body, pCRLF+14, pLF-15)
			end 
			if (matchRegex("(?im)^content-type\\s*:[^\\r\\n]*;\\s*charset\\s*=\\s*\"?([^\";\\r\\n]+)\"?", body, headersStart, pCRLF, pLF))
				charset = substring(body, pCRLF, pLF)
			end 
			
			// --- Build item (decode text fields only) ---
			if (fileName != "")
				item = newObject("name", name, "isFile", true, "fileName", this.safeFileName(fileName), "contentType", contentType, "data", slice)
			else 
				if (charset != "")
					txt = convertToString(slice, charset)
				else 
					txt = convertToString(slice, "utf-8")
				end 
				item = newObject("name", name, "isFile", false, "textValue", txt, "contentType", contentType)
			end 
			
			out.push(item)
			
			// --- Advance to the boundary we found and check if it's the final one ---
			isFinal = (substring(body, nextPos, lenDelim+2) == finalDelim)
			if (isFinal)
				break
			end 
			cursor = nextPos
		end 
	end 
	
function safeFileName(name : string)->out : string
	var s : string
	s = replaceString(name, "\"", "")
	s = replaceString(s, "/", "_")
	s = replaceString(s, ":", "_")
	s = replaceString(s, "..", ".")
	out = s
